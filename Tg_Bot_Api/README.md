### Скрипт взаимодействия с телеграм-ботом [Telegram Bot API](https://github.com/nickitey/backend_dev_roadmap/tree/main/projects/telegram_notification_service/sprint_2) на Python.

Взаимодействие с чат-ботом в Telegram реализовано в классе *TgBotClient*, отнаследованном в том числе от класса *requests.Session*, в связи с чем для работы требует установленный модуль *requests*.

Скрипт предоставляет возможность работы с телеграм-ботом посредством http-запросов к Telegram Bot API путем создания экземпляра класса и использования доступных методов:

1. **who_am_i()**:

*Аргументы*: не требуются.
    
*Возвращает*: строку формата 
        
```python
    Hello. I am bot. My name is {first_name}. You can find me at https://t.me/{username}.
```
    
    
2. **get_updates(**[updates_amount=5: **int**]**)**:

*Аргументы*: необязательный аргумент updates_amount: *int* - количество последних апдейтов бота (входящие, исходящие сообщения).
    
*Возвращает*: список словарей формата
    
```python
    [
        {
        'update_id': int, 
        'message': {
            'message_id': int, 
            'from': 
    	        {'id': int, 'is_bot': False, 'first_name': 'str', 'last_name': 'str', 'username': 'str', 'language_code': 'ru'}, 
            'chat': 
    	        {'id': str, 'first_name': 'str', 'last_name': 'str', 'username': 'str', 'type': 'private'}, 
            'date': int(UNIX time), 
            'text': 'str', 
            'entities':
    	        [{'offset': 0, 'length': 6, 'type': 'bot_command'}] 
            }
        }
     ...
     ]
```
Полный список возможных параметров словаря доступен в документации: общее описание объекта [ответа](https://core.telegram.org/bots/api#update), описание объекта [сообщения](https://core.telegram.org/bots/api#message).

**UPD**: Существует другой тип словаря, который возвращается сервером Telegram. Подробного описания этого словаря в документации к API нет. Этот словарь формируется и добавляется в апдейт после того, как пользователь остановил и заблокировал бота[^1] и/или разблокировал и заново его запустил. 

Выглядят такие словари следующим образом:

```python
{
    'update_id': int, 
    'my_chat_member': {
        'chat': {
            'id': int, 
            'first_name': '*name*', 
            'last_name': '*surname*', 
            'username': '*nickname*', 
            'type': 'private'
            },
        'from': {
            'id': int, 
            'is_bot': False, 
            'first_name': '*name*', 
            'last_name': '*surname*', 
            'username': '*nickname*', 
            'language_code': 'ru'
            }, 
        'date': int(UNIX time), 
        'old_chat_member': {
            'user': {
                'id': int, 
                'is_bot': True, 
                'first_name': 'Telegram Bot name', 
                'username': 'tg_bot_username'
                }, 
            'status': 'member'
            }, 
        'new_chat_member': {        # В случае блокировки бота пользователем 
            'user': {               # происходит отметка, что для данного пользователя
                'id': int,          # установлен новый статус бота
                'is_bot': True, 
                'first_name': 'Telegram Bot name', 
                'username': 'tg_bot_username'
                }, 
            'status': 'kicked',     # 'kicked'
            'until_date': 0
            }
        }
    }, {
    'update_id': int, 
    'my_chat_member': {
        'chat': {
            'id': int, 
            'first_name': '*name*', 
            'last_name': '*surname*', 
            'username': '*nickname*', 
            'type': 'private'
            }, 
        'from': {
            'id': int, 
            'is_bot': False, 
            'first_name': '*name*', 
            'last_name': '*surname*', 
            'username': '*nickname*',  
            'language_code': 'ru'
            }, 
        'date': int(UNIX time), 
        'old_chat_member': {
            'user': {
                'id': int, 
                'is_bot': True, 
                'first_name': 'Telegram Bot name', 
                'username': 'tg_bot_username'
                }, 
            'status': 'kicked', 
            'until_date': 0
            }, 
        'new_chat_member': {        # А в случае его разблокировки и перезапуска 
            'user': {               # отмечается, что пользователь снова стал
                'id': int, 
                'is_bot': True, 
                'first_name': 'Telegram Bot name', 
                'username': 'tg_bot_username'
                }, 
            'status': 'member'      # участником этого бота.
            }                       # Однако повторно сообщение '/start'
        }                           # от имени пользователя боту не отправляется.
    }                               # Эта особенность является существенной
                                    # для работы некоторых других методов API
                                    # (см. дальше).
```


[^1]: Возможность по отдельности остановить или заблокировать бота не предусмотрена разработчиками API Telegram.
	 
3. **send_the_message(** chat_id: **int**, text: **str)**:

*Аргументы*: id чата бота с пользователем[^2], текст сообщения к отправке.

*Возвращает*: объект ответа, который практического значения для пользователя не имеет.
        
Сообщение будет отправлено пользователю только в том случае, если id чата с ним занесен в список тех, кому бот может отправлять сообщения[^3]. 

[^2]: Его можно получить из апдейтов.
[^3]: См. описание метода *check_the_user()*.

4. **check_the_user(**, response: **list)**:

*Аргументы*: список словарей, возвращаемый методом *get_updates()*.

Одной из задач, вставших во время разработки проекта, явилось накопление списка пользователей, которые запустили у себя бот нажатием кнопки ```/start```, которая, в целом, не делает ничего, кроме отправки боту сообщения с текстом ```/start```.

При этом, однако, по документации к API Telegram, апдейты с сообщениями хранятся на сервере либо до того момента, когда пользователь подтвердит их получение[^4], либо в течение 24 часов с момента наступления события. Таким образом, если своевременно не зафиксировать, что пользователь отправил боту команду ```/start```, получить данные сведения в последующем не представляется возможным (во всяком случае, так следует из официальной документации).

Для решения данной задачи при инициализации экземпляра класса *TgBotClient* происходит попытка открыть файл *.users_list*, в котором должны храниться *id* чатов с пользователями, отправившими команду ```/start``` боту. 

Если такой файл отстутствует, в лог файл записывается соответствующая информация.

Если открытие файла произошло успешно, в атрибут *allowed_users* из файла записывается список *id* указанных пользователей.

Метод *check_the_user()* итерирует возвращенный методом *get_updates()* ответ и проверяет наличие новых сообщений ```/start``` от *новых* пользователей (которые отсутствуют в списке *allowed_users*), после чего добавляет их в список *allowed_users*, а в конце перезаписывает в файл *.users_list* все *id* пользователей из списка *allowed_users*.

В случае, если во время очередной итерации в обновление попадает объект с информацией об остановке и/или о перезапуске бота пользователем[^5], информация об этом с указанием номера апдейта логируется в файл, поиск текста сообщения в текущем апдейте прекращается, цикл уходит на новую итерацию (если есть другие элементы в итераторе).

Если с момента прошлой сессии в список добавились новые пользователи, то во время добавления в список *allowed_users* логируется соответствующая информация c их именами, фамилиями и *id*, а во время записи в файл - информация об обновлении соответствующей информации в файле с момента его открытия.

[^4]: Для подтверждения получения апдейта в методе *get_update()* необходимо одном из параметров HTTP-запроса указать ```"offset": [id_последнего_полученного_апдейта]```. После этого сервер считает, что получение предыдущих апдейтов подверждено и при последующих запросов апдейтов возвращает только последний подтвержденный апдейт и те апдейты, которые хронологически (преимущественно) произошли после последнего подтвержденного.
[^5]: См. раздел *UPD* в п. 2, *get_updates()*.
